#!/usr/bin/env python3
import argparse
import json
import os
import sys
import time
from typing import Any, Dict, Optional, Tuple

import httpx


def _parse_args() -> argparse.Namespace:
    parser = argparse.ArgumentParser(description="Trigger and poll a full wrapped pipeline run via admin endpoints.")
    parser.add_argument(
        "--base-url",
        default=os.getenv("BACKEND_BASE_URL") or os.getenv("BASE_URL") or "http://localhost:8080",
        help="Backend base URL (default: $BACKEND_BASE_URL, else $BASE_URL, else http://localhost:8080)",
    )
    parser.add_argument(
        "--admin-key",
        default=os.getenv("ADMIN_API_KEY"),
        help="Admin API key (default: $ADMIN_API_KEY)",
    )
    parser.add_argument("--sec-user-id", required=True, help="TikTok sec_user_id to run wrapped for")
    parser.add_argument("--email", required=True, help="Destination email (SES must be configured)")
    parser.add_argument("--username", default=None, help="TikTok username (without @ is fine)")
    parser.add_argument("--time-zone", default="UTC", help="IANA time zone, e.g. America/Los_Angeles (default: UTC)")
    parser.add_argument("--app-user-id", default=None, help="Optional fixed app_user_id (default: autogenerated)")
    parser.add_argument(
        "--reuse-run",
        action="store_true",
        help="Reuse existing run for (app_user_id, sec_user_id) if present instead of forcing a new run",
    )
    parser.add_argument("--poll-seconds", type=float, default=2.0, help="Polling interval (default: 2)")
    parser.add_argument("--timeout-seconds", type=float, default=900.0, help="Max wait time (default: 900)")
    parser.add_argument("--print-json", action="store_true", help="Print full status JSON every poll")
    parser.add_argument(
        "--no-wait-email",
        action="store_true",
        help="Exit once run_status is ready (do not wait for email_send to succeed)",
    )
    return parser.parse_args()


def _job_status(status: Dict[str, Any], name: str) -> Optional[str]:
    jobs = status.get("jobs") if isinstance(status.get("jobs"), dict) else {}
    db_ref = jobs.get(name)
    if isinstance(db_ref, dict):
        value = db_ref.get("status")
        if isinstance(value, str):
            return value
    data_jobs = status.get("data_jobs") if isinstance(status.get("data_jobs"), dict) else {}
    payload_ref = data_jobs.get(name)
    if isinstance(payload_ref, dict):
        value = payload_ref.get("status")
        if isinstance(value, str):
            return value
    return None


def _summarize_status(status: Dict[str, Any]) -> Tuple[str, str]:
    run_status = str(status.get("run_status") or "")
    data_jobs = status.get("data_jobs") if isinstance(status.get("data_jobs"), dict) else {}
    jobs = status.get("jobs") if isinstance(status.get("jobs"), dict) else {}

    def job_line(name: str) -> Optional[str]:
        payload_ref = data_jobs.get(name)
        payload_status = payload_ref.get("status") if isinstance(payload_ref, dict) else None
        db_ref = jobs.get(name)
        db_status = db_ref.get("status") if isinstance(db_ref, dict) else None
        if not payload_status and not db_status:
            return None
        if payload_status and db_status:
            return f"{name}={payload_status}/{db_status}"
        return f"{name}={payload_status or db_status}"

    parts = [
        job_line("watch_history"),
        job_line("wrapped_analysis"),
        job_line("email_send"),
        job_line("watch_history_fetch_2025"),
    ]
    parts = [p for p in parts if p]
    return run_status, " ".join(parts)


def main() -> int:
    args = _parse_args()
    if not args.admin_key:
        print("Missing --admin-key (or set ADMIN_API_KEY).", file=sys.stderr)
        return 2

    base_url = str(args.base_url).rstrip("/")
    headers = {"X-Admin-Key": args.admin_key}

    run_req: Dict[str, Any] = {
        "sec_user_id": args.sec_user_id,
        "email": args.email,
        "platform_username": args.username,
        "time_zone": args.time_zone,
        "app_user_id": args.app_user_id,
        "force_new_run": not bool(args.reuse_run),
    }
    run_req = {k: v for k, v in run_req.items() if v is not None}

    with httpx.Client(timeout=30.0) as client:
        resp = client.post(f"{base_url}/admin/test/run", headers=headers, json=run_req)
        if resp.status_code >= 400:
            print(f"POST /admin/test/run failed: {resp.status_code} {resp.text}", file=sys.stderr)
            return 1
        data = resp.json()

        wrapped_run_id = data["wrapped_run_id"]
        app_user_id = data["app_user_id"]
        status_url = f"{base_url}{data['admin_status_endpoint']}"
        wrapped_url = f"{base_url}{data['wrapped_status_endpoint']}"

        print("Triggered admin test run:")
        print(f"  app_user_id: {app_user_id}")
        print(f"  wrapped_run_id: {wrapped_run_id}")
        print(f"  wrapped_link: {data.get('wrapped_link')}")
        print(f"  status: {status_url}")
        print(f"  public wrapped status: {wrapped_url}")

        start = time.time()
        last_summary = ""
        while True:
            st = client.get(status_url, headers=headers)
            if st.status_code >= 400:
                print(f"GET status failed: {st.status_code} {st.text}", file=sys.stderr)
                return 1
            status = st.json()
            if args.print_json:
                print(json.dumps(status, indent=2, ensure_ascii=False))
            run_status, jobs_summary = _summarize_status(status)
            summary = f"run_status={run_status} {jobs_summary}".strip()
            if summary != last_summary:
                print(summary)
                last_summary = summary

            if run_status == "failed":
                print("Done: run_status=failed")
                return 1

            if run_status == "ready":
                if args.no_wait_email:
                    print("Done: run_status=ready")
                    return 0
                email_status = _job_status(status, "email_send")
                if email_status == "succeeded":
                    print("Done: run_status=ready email_send=succeeded")
                    return 0
                if email_status == "failed":
                    print("Done: run_status=ready email_send=failed")
                    return 1

            if time.time() - start > float(args.timeout_seconds):
                print(f"Timed out after {args.timeout_seconds:.0f}s", file=sys.stderr)
                return 1
            time.sleep(float(args.poll_seconds))


if __name__ == "__main__":
    raise SystemExit(main())
